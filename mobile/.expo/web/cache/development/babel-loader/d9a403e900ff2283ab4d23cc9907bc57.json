{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nexport function base64toBlob(base64Data, contentType) {\n  contentType = contentType || '';\n  var sliceSize = 1024;\n  var byteCharacters = atob(base64Data);\n  var bytesLength = byteCharacters.length;\n  var slicesCount = Math.ceil(bytesLength / sliceSize);\n  var byteArrays = new Array(slicesCount);\n\n  for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {\n    var begin = sliceIndex * sliceSize;\n    var end = Math.min(begin + sliceSize, bytesLength);\n    var bytes = new Array(end - begin);\n\n    for (var offset = begin, i = 0; offset < end; ++i, ++offset) {\n      bytes[i] = byteCharacters[offset].charCodeAt(0);\n    }\n\n    byteArrays[sliceIndex] = new Uint8Array(bytes);\n  }\n\n  return new Blob(byteArrays, {\n    type: contentType\n  });\n}\nexport function blobToBase64Async(blob) {\n  return new Promise(function (resolve, _) {\n    var reader = new FileReader();\n\n    reader.onloadend = function () {\n      return resolve(reader.result);\n    };\n\n    reader.readAsDataURL(blob);\n  });\n}\nexport function htmlToPlainText(html) {\n  var tempDivElement = document.createElement('div');\n  tempDivElement.innerHTML = html;\n  return tempDivElement.textContent || tempDivElement.innerText || '';\n}\nexport function getImageSizeFromBlobAsync(blob) {\n  return new Promise(function (resolve, _) {\n    var blobUrl = URL.createObjectURL(blob);\n    var img = document.createElement('img');\n    img.src = blobUrl;\n\n    img.onload = function () {\n      resolve({\n        width: img.width,\n        height: img.height\n      });\n    };\n  });\n}\nexport function findImageInClipboardAsync(_x) {\n  return _findImageInClipboardAsync.apply(this, arguments);\n}\n\nfunction _findImageInClipboardAsync() {\n  _findImageInClipboardAsync = _asyncToGenerator(function* (items) {\n    for (var clipboardItem of items) {\n      if (clipboardItem.types.some(function (type) {\n        return type === 'image/png';\n      })) {\n        return yield clipboardItem.getType('image/png');\n      }\n\n      if (clipboardItem.types.some(function (type) {\n        return type === 'image/jpeg';\n      })) {\n        return yield clipboardItem.getType('image/jpeg');\n      }\n    }\n\n    return null;\n  });\n  return _findImageInClipboardAsync.apply(this, arguments);\n}\n\nexport function findHtmlInClipboardAsync(_x2) {\n  return _findHtmlInClipboardAsync.apply(this, arguments);\n}\n\nfunction _findHtmlInClipboardAsync() {\n  _findHtmlInClipboardAsync = _asyncToGenerator(function* (items) {\n    for (var clipboardItem of items) {\n      if (clipboardItem.types.some(function (type) {\n        return type === 'text/html';\n      })) {\n        return yield clipboardItem.getType('text/html');\n      }\n    }\n\n    return null;\n  });\n  return _findHtmlInClipboardAsync.apply(this, arguments);\n}\n\nexport function isClipboardPermissionDeniedAsync() {\n  return _isClipboardPermissionDeniedAsync.apply(this, arguments);\n}\n\nfunction _isClipboardPermissionDeniedAsync() {\n  _isClipboardPermissionDeniedAsync = _asyncToGenerator(function* () {\n    var queryOpts = {\n      name: 'clipboard-read'\n    };\n    var permissionStatus = yield navigator.permissions.query(queryOpts);\n    return permissionStatus.state === 'denied';\n  });\n  return _isClipboardPermissionDeniedAsync.apply(this, arguments);\n}","map":{"version":3,"mappings":"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","names":["base64toBlob","base64Data","contentType","sliceSize","byteCharacters","atob","bytesLength","length","slicesCount","Math","ceil","byteArrays","Array","sliceIndex","begin","end","min","bytes","offset","i","charCodeAt","Uint8Array","Blob","type","blobToBase64Async","blob","Promise","resolve","_","reader","FileReader","onloadend","result","readAsDataURL","htmlToPlainText","html","tempDivElement","document","createElement","innerHTML","textContent","innerText","getImageSizeFromBlobAsync","blobUrl","URL","createObjectURL","img","src","onload","width","height","findImageInClipboardAsync","items","clipboardItem","types","some","getType","findHtmlInClipboardAsync","isClipboardPermissionDeniedAsync","queryOpts","name","permissionStatus","navigator","permissions","query","state"],"sourceRoot":"","sources":["../../src/web/Utils.ts"],"sourcesContent":["/**\n * Converts base64-encoded data to a `Blob` object.\n * @see https://stackoverflow.com/a/20151856\n */\nexport function base64toBlob(base64Data: string, contentType: string): Blob {\n  contentType = contentType || '';\n  const sliceSize = 1024;\n  const byteCharacters = atob(base64Data);\n  const bytesLength = byteCharacters.length;\n  const slicesCount = Math.ceil(bytesLength / sliceSize);\n  const byteArrays = new Array(slicesCount);\n\n  for (let sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {\n    const begin = sliceIndex * sliceSize;\n    const end = Math.min(begin + sliceSize, bytesLength);\n\n    const bytes = new Array(end - begin);\n    for (let offset = begin, i = 0; offset < end; ++i, ++offset) {\n      bytes[i] = byteCharacters[offset].charCodeAt(0);\n    }\n    byteArrays[sliceIndex] = new Uint8Array(bytes);\n  }\n  // I cannot use `@ts-expect-error` here because some environments consider this correct:\n  // expo-module build - OK,\n  // expo-module test - error\n  // @ts-ignore `Blob` from `lib.dom.d.ts` and the one from `@types/react-native` differ somehow\n  return new Blob(byteArrays, { type: contentType });\n}\n\n/**\n * Converts blob to base64-encoded string with Data-URL prefix.\n */\nexport function blobToBase64Async(blob: Blob): Promise<string> {\n  return new Promise((resolve, _) => {\n    const reader = new FileReader();\n    reader.onloadend = () => resolve(reader.result as string);\n    reader.readAsDataURL(blob);\n  });\n}\n\nexport function htmlToPlainText(html: string) {\n  const tempDivElement = document.createElement('div');\n  tempDivElement.innerHTML = html;\n  return tempDivElement.textContent || tempDivElement.innerText || '';\n}\n\nexport function getImageSizeFromBlobAsync(blob: Blob): Promise<{ width: number; height: number }> {\n  return new Promise((resolve, _) => {\n    const blobUrl = URL.createObjectURL(blob);\n    const img = document.createElement('img');\n    img.src = blobUrl;\n    img.onload = function () {\n      resolve({ width: img.width, height: img.height });\n    };\n  });\n}\n\nexport async function findImageInClipboardAsync(items: ClipboardItems): Promise<Blob | null> {\n  for (const clipboardItem of items) {\n    // first look for png\n    if (clipboardItem.types.some((type) => type === 'image/png')) {\n      return await clipboardItem.getType('image/png');\n    }\n\n    // alternatively, an image might be a jpeg\n    // NOTE: Currently, this is not supported by browsers yet. They only support PNG now\n    if (clipboardItem.types.some((type) => type === 'image/jpeg')) {\n      return await clipboardItem.getType('image/jpeg');\n    }\n  }\n  return null;\n}\n\nexport async function findHtmlInClipboardAsync(items: ClipboardItems): Promise<Blob | null> {\n  for (const clipboardItem of items) {\n    if (clipboardItem.types.some((type) => type === 'text/html')) {\n      return await clipboardItem.getType('text/html');\n    }\n  }\n  return null;\n}\n\nexport async function isClipboardPermissionDeniedAsync(): Promise<boolean> {\n  const queryOpts = { name: 'clipboard-read' as PermissionName };\n  const permissionStatus = await navigator.permissions.query(queryOpts);\n  return permissionStatus.state === 'denied';\n}\n"]},"metadata":{},"sourceType":"module"}